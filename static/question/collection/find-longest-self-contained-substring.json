{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "3104",
            "title": "Find Longest Self-Contained Substring",
            "titleSlug": "find-longest-self-contained-substring",
            "content": null,
            "isPaidOnly": true,
            "difficulty": "Hard",
            "likes": 7,
            "dislikes": 3,
            "similarQuestions": "[]",
            "topicTags": [
                {
                    "name": "Hash Table",
                    "slug": "hash-table"
                },
                {
                    "name": "String",
                    "slug": "string"
                },
                {
                    "name": "Binary Search",
                    "slug": "binary-search"
                },
                {
                    "name": "Prefix Sum",
                    "slug": "prefix-sum"
                }
            ],
            "stats": "{\"totalAccepted\": \"434\", \"totalSubmission\": \"738\", \"totalAcceptedRaw\": 434, \"totalSubmissionRaw\": 738, \"acRate\": \"58.8%\"}",
            "hints": [
                "Fix the start index of the substring.",
                "For some fixed index <code>start</code>, let's try to find some index <code>end</code> such that this substring satisfies the property and also <code>end</code> is as maximum as possible.",
                "Write some recursive function <code>shrink(start, end)</code> that gives a substring. If the substring is valid, then return <code>end</code>. Otherwise, it reduces <<code>end</code> to reach some valid <code>end</code>.",
                "For some <code>shrink(start, end)</code>, if the substring is not valid, it means there is some character that is both inside and outside of the substring. Now try to reduce <code>end</code> such that it does not contain that character anymore.",
                "If you implement the <code>shrink(start, end)</code> function optimally, you'll achieve <code>O(n * 26 * 26)</code> by using partial sum."
            ]
        },
        "similar": [],
        "hints": [
            "Fix the start index of the substring.",
            "For some fixed index <code>start</code>, let's try to find some index <code>end</code> such that this substring satisfies the property and also <code>end</code> is as maximum as possible.",
            "Write some recursive function <code>shrink(start, end)</code> that gives a substring. If the substring is valid, then return <code>end</code>. Otherwise, it reduces <<code>end</code> to reach some valid <code>end</code>.",
            "For some <code>shrink(start, end)</code>, if the substring is not valid, it means there is some character that is both inside and outside of the substring. Now try to reduce <code>end</code> such that it does not contain that character anymore.",
            "If you implement the <code>shrink(start, end)</code> function optimally, you'll achieve <code>O(n * 26 * 26)</code> by using partial sum."
        ],
        "relatedTopics": [
            {
                "name": "Hash Table",
                "slug": "hash-table"
            },
            {
                "name": "String",
                "slug": "string"
            },
            {
                "name": "Binary Search",
                "slug": "binary-search"
            },
            {
                "name": "Prefix Sum",
                "slug": "prefix-sum"
            }
        ]
    }
}