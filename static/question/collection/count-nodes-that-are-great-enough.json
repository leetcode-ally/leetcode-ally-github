{
    "failed": false,
    "status": 200,
    "message": "Question Data fetched successfully",
    "data": {
        "question": {
            "questionFrontendId": "2792",
            "title": "Count Nodes That Are Great Enough",
            "titleSlug": "count-nodes-that-are-great-enough",
            "content": null,
            "isPaidOnly": true,
            "difficulty": "Hard",
            "likes": 18,
            "dislikes": 0,
            "similarQuestions": "[]",
            "topicTags": [
                {
                    "name": "Divide and Conquer",
                    "slug": "divide-and-conquer"
                },
                {
                    "name": "Tree",
                    "slug": "tree"
                },
                {
                    "name": "Depth-First Search",
                    "slug": "depth-first-search"
                },
                {
                    "name": "Binary Tree",
                    "slug": "binary-tree"
                }
            ],
            "stats": "{\"totalAccepted\": \"727\", \"totalSubmission\": \"1.2K\", \"totalAcceptedRaw\": 727, \"totalSubmissionRaw\": 1235, \"acRate\": \"58.9%\"}",
            "hints": [
                "<div class=\"_1l1MA\">For each node, calculate a list of <code>k</code> values representing <code>k</code> smallest values in the subtree of that node.</div>",
                "<div class=\"_1l1MA\">To check if a node is great enough, get the described list in the first hint for its children and merge them. Since the resulting list may contain more than <code>k</code> elements, pick <code>k</code> smallest values and discard the extra ones.</div>",
                "<div class=\"_1l1MA\">Now check if the merged list has exactly <code>k</code> elements, and the current node's value is greater than the greatest element in the list, then that node is great enough.</div>"
            ]
        },
        "similar": [],
        "hints": [
            "<div class=\"_1l1MA\">For each node, calculate a list of <code>k</code> values representing <code>k</code> smallest values in the subtree of that node.</div>",
            "<div class=\"_1l1MA\">To check if a node is great enough, get the described list in the first hint for its children and merge them. Since the resulting list may contain more than <code>k</code> elements, pick <code>k</code> smallest values and discard the extra ones.</div>",
            "<div class=\"_1l1MA\">Now check if the merged list has exactly <code>k</code> elements, and the current node's value is greater than the greatest element in the list, then that node is great enough.</div>"
        ],
        "relatedTopics": [
            {
                "name": "Divide and Conquer",
                "slug": "divide-and-conquer"
            },
            {
                "name": "Tree",
                "slug": "tree"
            },
            {
                "name": "Depth-First Search",
                "slug": "depth-first-search"
            },
            {
                "name": "Binary Tree",
                "slug": "binary-tree"
            }
        ]
    }
}